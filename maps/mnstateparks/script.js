/* Visit Minnesota's State Parks — interactive map
   - Polygons from MN DNR FeatureServer (GeoJSON)
   - Metadata from parks.json (scraper output)
   - Basemap auto-switch to topo at z >= 18
   - Search and highlight filters
   - Styled popups with optional Wikimedia photo
   - Colors: Minnesota state flag palette
*/

// ---- Config ----
const FS_URL =
  "https://arcgis.dnr.state.mn.us/host/rest/services/Hosted/Minnesota_State_Parks_Recreation_Areas_Waysides/FeatureServer/1";
const FS_QUERY =
  `${FS_URL}/query?where=1%3D1&outFields=area_name,area_type,gis_acres,legislative_name&outSR=4326&f=geojson`;
const PARKS_JSON = "parks.json"; // generated by your scraper

// Colors
const FLAG = {
  light:"#63B3FF", dark:"#0B4F6C", yellow:"#FFC107", white:"#FFFFFF"
};

// ---- Map init (no zoom controls per your defaults) ----
const map = L.map("map", {
  zoomControl: false,
  preferCanvas: true
});

// Light basemap (roads, places)
const baseLight = L.tileLayer(
  // CARTO Positron raster tiles (public), with required attribution
  "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png",
  {
    subdomains: "abcd",
    minZoom: 0, maxZoom: 20,
    attribution:
      '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> ' +
      'contributors • Tiles © <a href="https://carto.com/basemaps/">CARTO</a>'
  }
).addTo(map);

// Topo basemap (switch on close zoom)
const baseTopo = L.tileLayer(
  "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
  {
    subdomains: "abc",
    minZoom: 0, maxZoom: 20, opacity: 0,
    attribution:
      'Map data © <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, SRTM | ' +
      'Style: © <a href="https://opentopomap.org">OpenTopoMap</a>'
  }
).addTo(map);

// Basemap switcher at zoom ≥ 18
function syncBasemap() {
  const z = map.getZoom();
  if (z >= 18) {
    baseTopo.setOpacity(1);
    baseLight.setOpacity(0);
  } else {
    baseTopo.setOpacity(0);
    baseLight.setOpacity(1);
  }
}
map.on("zoomend", syncBasemap);

// ---- UI wiring ----
const $ = sel => document.querySelector(sel);
const panel = $("#panelContents");
$("#panelToggle").addEventListener("click", () => {
  const isOpen = !panel.hasAttribute("hidden");
  if (isOpen) panel.setAttribute("hidden",""); else panel.removeAttribute("hidden");
});

const infoBtn = $("#infobtn");
const infoBox = $("#infobox");
const infoClose = $("#infoclose");
infoBtn.addEventListener("click", ()=> infoBox.hidden = !infoBox.hidden);
infoClose.addEventListener("click", ()=> infoBox.hidden = true);

// ---- Helpers ----
const slug = s => (s||"").normalize("NFKD")
  .replace(/\(.*?\)/g,"")
  .replace(/state\s+(park|recreation\s+area|wayside)/gi,"")
  .replace(/[^\w]+/g,"-").replace(/-+/g,"-").replace(/^-|-$|_/g,"").toLowerCase();

function acresLabel(val){
  if (val == null) return "n/a";
  const ac = Number(val);
  if (isNaN(ac)) return "n/a";
  return Intl.NumberFormat("en-US").format(Math.round(ac)) + " acres";
}

function buildNarrative(name, highlights, hours, areaType){
  // 100–150 words, friendly tone. Compose from bits we have.
  const h = (highlights||[]).slice(0,5);
  const typeTxt = (areaType || "State Park").replace(/\b\w/g,c=>c.toUpperCase());
  const openTxt = hours ? "Hours: " + hours.replace(/^hours:\s*/i,"") + ". " : "";
  const vibe = [
    "Bring your curiosity and a sense of wonder—",
    "Pack your camera and an easygoing pace—",
    "Come for the scenery, stay for the quiet—",
    "It’s a perfect day-trip or weekend wander—"
  ];
  const line1 = `${name} is a Minnesota ${typeTxt} inviting you to slow down and explore. `;
  const line2 = h.length ? `Highlights include ${h.map(x=>x.toLowerCase()).join(", ").replace(/, ([^,]*)$/," and $1")}. ` : "";
  const line3 = "Trails and overlooks reveal classic North Country textures—water, rock, forest, and sky—layered in every season. ";
  const line4 = "Wayfinding is simple, amenities are close at hand, and there’s always a quieter path if you want it. ";
  const line5 = openTxt + "Whether this is your first visit or your fiftieth, the park rewards unhurried moments and a little curiosity.";

  // Trim to ~120–140 words
  return (line1 + line2 + line3 + line4 + line5);
}

// ---- Data containers ----
let metaBySlug = new Map();
let featuresLayer = null;
let allFeatures = [];
let lastHover = null;

// ---- Load metadata then polygons ----
Promise.all([
  fetch(PARKS_JSON).then(r=>r.json()),
  fetch(FS_QUERY).then(r=>r.json())
]).then(([parks, geojson])=>{
  // index metadata by slug_bare and slug_full (robust join)
  parks.forEach(p=>{
    if (p.slug_bare) metaBySlug.set(p.slug_bare, p);
    if (p.slug_full) metaBySlug.set(p.slug_full, p);
    // also index plain name variants
    if (p.name_bare) metaBySlug.set(slug(p.name_bare), p);
    if (p.name_full) metaBySlug.set(slug(p.name_full), p);
  });

  // style for polygons
  function parkStyle(){
    return {
      color: FLAG.dark,
      weight: 2,
      opacity: 1,
      fillColor: FLAG.light,
      fillOpacity: 0.2
    };
  }

  function onEachFeature(feat, layer){
    const props = feat.properties || {};
    const joinKeyCandidates = [
      slug(props.area_name || ""),
      slug(props.legislative_name || "")
    ].filter(Boolean);

    let parkMeta = null;
    for (const k of joinKeyCandidates){
      if (metaBySlug.has(k)){ parkMeta = metaBySlug.get(k); break; }
    }

    // hover styling
    layer.on("mouseover", (e)=>{
      if (lastHover && lastHover !== layer){
        lastHover.setStyle({weight:2, fillOpacity:0.2});
        lastHover._path && lastHover._path.classList.remove("feature-hover");
      }
      layer.setStyle({weight:3.5, fillOpacity:0.28});
      lastHover = layer;
      layer._path && layer._path.classList.add("feature-hover");
    });
    layer.on("mouseout", ()=>{
      layer.setStyle({weight:2, fillOpacity:0.2});
      layer._path && layer._path.classList.remove("feature-hover");
    });

    // popup
    layer.on("click", ()=>{
      const name = props.area_name || (parkMeta && parkMeta.park_name) || "Minnesota State Park";
      const areaType = props.area_type || "State Park";
      const acres = acresLabel(props.gis_acres);
      const hls = (parkMeta && parkMeta.highlights) || [];
      const hours = parkMeta && parkMeta.hours;
      const url = (parkMeta && parkMeta.official_url) || null;
      const img = parkMeta && parkMeta.image;

      const narrative = buildNarrative(name, hls, hours, areaType);

      const hero = img && img.image_thumb
        ? `<div class="card__hero"><img src="${img.image_thumb}" alt="${name} photo"></div>`
        : `<div class="card__hero" style="padding:12px 12px 10px 12px;">
             <span class="badge">Explore Minnesota</span>
           </div>`;

      const highlightsList = hls.length
        ? `<ul class="list">${hls.slice(0,8).map(t=>`<li>${t}</li>`).join("")}</ul>`
        : `<div class="meta">Highlights: <em>See official page for details.</em></div>`;

      const photoCredit = img && img.page_url
        ? `<div class="small" style="margin-top:.4rem;color:#597389;">Photo: <a href="${img.page_url}" target="_blank" rel="noopener">Wikimedia/Wikipedia</a></div>`
        : "";

      const link = url
        ? `<a class="link" href="${url}" target="_blank" rel="noopener">Official DNR page →</a>`
        : "";

      const html = `
        <div class="card">
          ${hero}
          <div class="card__body">
            <div class="card__title">${name}</div>
            <div class="meta"><b>Type:</b> ${areaType} &nbsp;•&nbsp; <b>Area:</b> ${acres}</div>
            <hr class="hr" />
            <div class="sec-title">Park highlights</div>
            ${highlightsList}
            <div class="sec-title" style="margin-top:.6rem;">Hours</div>
            <div class="meta">${hours ? hours : "<em>See official page</em>"}</div>
            <hr class="hr" />
            <div class="sec-title">Why visit</div>
            <div class="meta" style="line-height:1.45">${narrative}</div>
            ${link}
            ${photoCredit}
          </div>
        </div>
      `;
      layer.bindPopup(html, {maxWidth: 420}).openPopup();
    });
  }

  featuresLayer = L.geoJSON(geojson, {
    style: parkStyle,
    onEachFeature
  }).addTo(map);

  allFeatures = featuresLayer.getLayers();

  // Fit & constrain bounds (~±5° buffer to keep users near MN)
  const b = featuresLayer.getBounds();
  map.fitBounds(b, {padding:[40,40]});
  const pad = 5.0; // degrees
  const maxBounds = L.latLngBounds(
    L.latLng(b.getSouth() - pad, b.getWest() - pad),
    L.latLng(b.getNorth() + pad, b.getEast() + pad)
  );
  map.setMaxBounds(maxBounds);

  // Build highlight vocabulary
  populateHighlightDropdown(parks);

  // Hook up search
  wireSearch();

  // Initial basemap sync
  syncBasemap();

  // Attribution — add Web Mapper GPT credit
  map.attributionControl.addAttribution('Design & build: <a href="#" target="_blank" rel="noopener">Web Mapper GPT</a>');

}).catch(err=>{
  console.error(err);
  alert("Failed to load data. Check network and try again.");
});

// ---- Filters & Search ----
function populateHighlightDropdown(parks){
  // Collect distinct highlight phrases (simple approach: use the raw bullet text)
  const set = new Set();
  parks.forEach(p=>{
    (p.highlights||[]).forEach(h=>{
      const t = (h||"").trim();
      if (t && t.length <= 60) set.add(t);
    });
  });
  const opts = Array.from(set).sort((a,b)=> a.localeCompare(b));
  const sel = document.getElementById("highlightSelect");
  opts.forEach(t=>{
    const o = document.createElement("option");
    o.value = t.toLowerCase();
    o.textContent = t;
    sel.appendChild(o);
  });
  sel.addEventListener("change", ()=> applyFilters());
}

function wireSearch(){
  const input = document.getElementById("searchInput");
  input.addEventListener("input", ()=> applyFilters());
}

function applyFilters(){
  const q = (document.getElementById("searchInput").value || "").trim().toLowerCase();
  const sel = document.getElementById("highlightSelect").value;

  featuresLayer.eachLayer(layer=>{
    const f = layer.feature;
    const name = (f.properties.area_name || "").toLowerCase();
    // join to metadata to test highlights
    const k = slug(f.properties.area_name || "");
    const meta = metaBySlug.get(k);
    const highlights = ((meta && meta.highlights) || []).map(h=>h.toLowerCase());

    const matchName = !q || name.includes(q);
    const matchHl = !sel || highlights.some(h=> h.includes(sel));

    const visible = matchName && matchHl;
    if (visible){
      layer.addTo(map);
    }else{
      map.removeLayer(layer);
    }
  });

  // If a single match by name, zoom to it
  if (q.length > 1){
    const hits = [];
    featuresLayer.eachLayer(l=>{
      if (map.hasLayer(l)){
        const nm = (l.feature.properties.area_name || "").toLowerCase();
        if (nm.includes(q)) hits.push(l);
      }
    });
    if (hits.length === 1){
      map.fitBounds(hits[0].getBounds(), {maxZoom: 14, padding:[30,30]});
    }
  }
}
